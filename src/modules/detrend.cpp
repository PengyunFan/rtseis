#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstdint>
#include <ipps.h>
#define RTSEIS_LOGGING 1
#include "rtseis/log.h"
#include "rtseis/modules/detrend.hpp"

using namespace RTSeis::Modules;

class Detrend::DetrendImpl
{
    public:
        DetrendImpl(void)
        { 
            return;
        }
        /// Copy constructor
        DetrendImpl(const DetrendImpl &detrend)
        {
            *this = detrend;
            return;
        }
        /// Deep copy operator
        DetrendImpl& operator=(const DetrendImpl &detrend)
        {
            if (&detrend == this){return *this;}
            parms_ = detrend.parms_;
            b0_ = detrend.b0_;
            b1_ = detrend.b1_;
            linit_ = detrend.linit_;
            return *this;
        }
        /// Destructor
        ~DetrendImpl(void)
        {
            clear();
            return;
        }
        /// Resets the module
        void clear(void)
        {
            parms_.clear();
            b0_ = 0;
            b1_ = 0;
            linit_ = true; // This module is always ready to roll
            return;
        }
        /// Sets the parameters for the class
        int setParameters(const DetrendParameters parameters)
        {
            clear();
            parms_ = parameters;
            return 0;
        }
        /// Removes the trend from data
        int detrend(const int nx, const double x[], double y[])
        {
            b0_ = 0;
            b1_ = 0;
            if (nx < 2){return 0;}
            computeLinearRegressionCoeffs(nx, x);
            #pragma omp simd
            for (int i=0; i<nx; i++)
            {
                y[i] = x[i] - (b0_ + b1_*static_cast<double> (i));
            }
            return 0;
        } 
        /// Removes the trend from data
        int detrend(const int nx, const float x[], float y[])
        {
            b0_ = 0;
            b1_ = 0;
            if (nx < 2){return 0;} 
            computeLinearRegressionCoeffs(nx, x); 
            float b0 = static_cast<float> (b0_);
            float b1 = static_cast<float> (b1_);
            #pragma omp simd
            for (int i=0; i<nx; i++)
            {
                y[i] = x[i] - (b0 + b1*static_cast<float> (i));
            }
            return 0;
        }
         /*!
          * @brief Computes the coefficients for a linear regression
          *          \f$ \hat{y}_i = b_0 + b_1 x_i \f$
          *        using IPP functions where
          *          \f$ b_1
          *           = \frac{\mathrm{Cov}(x,y)}{\mathrm{Var}(x,y)} \f$
          *        and 
          *          \f$ b_0 = \bar{y} - b_0 \bar{x} \f$.
          *        The code is modified from:
          *        https://software.intel.com/en-us/forums/intel-integrated-performance-primitives/topic/299457 
          *        where I have assumed the data is generated by linearly
          *        spaced samples.
          * @param[in] length  Length of array y.
          * @param[in] pSrcY   Points at evaluated at indices.
          */
        int computeLinearRegressionCoeffs(
            const int length, const double pSrcY[])
        {
            double cov_xy;
            double mean_x;
            double mean_y;
            double var_x;
            // Mean of x - analytic formula for evenly spaced samples starting
            // at indx 0. This is computed by simplifying Gauss's formula.
            uint64_t len64 = static_cast<uint64_t> (length);
            mean_x = 0.5*static_cast<double> (len64 - 1);
            // Note, the numerator is the sum of consecutive squared numbers.
            // In addition we simplify.
            var_x = static_cast<double> ( ((len64 - 1))*(2*(len64 - 1) + 1) )/6.
                  - mean_x*mean_x;
            ippsMean_64f(pSrcY, length, &mean_y);
            cov_xy = 0; 
            #pragma omp simd reduction(+:cov_xy)
            for (int i=0; i<length; i++)
            {
                cov_xy = cov_xy + static_cast<double> (i)*pSrcY[i];
            }
            // This is computed by expanding (x_i - bar(x))*(y_i - bar(y)),
            // using the definition of the mean, and simplifying
            cov_xy = (cov_xy/static_cast<double> (length)) - mean_x*mean_y;
            b1_ = cov_xy/var_x;
            b0_  = mean_y - b1_*mean_x;
            return 0; 
        }
        /// Computes the linear regression coefficients
        int computeLinearRegressionCoeffs(
            const int length, const float pSrcY[])
        {
            double cov_xy;
            double mean_x;
            double mean_y;
            double var_x;
            float mean_y32;
            // Mean of x - analytic formula for evenly spaced samples starting
            // at indx 0.  This is computed by simplifying Gauss's formula.
            uint64_t len64 = static_cast<uint64_t> (length);
            mean_x = 0.5*static_cast<double> (len64 - 1); 
            // Note, the numerator is the sum of consecutive squared numbers.
            // In addition we simplify.
            var_x = static_cast<double> ( ((len64 - 1))*(2*(len64 - 1) + 1) )/6.
                  - mean_x*mean_x;
            ippsMean_32f(pSrcY, length, &mean_y32, ippAlgHintAccurate); 
            mean_y = static_cast<double> (mean_y32);
            cov_xy = 0;
            #pragma omp simd reduction(+:cov_xy)
            for (int i=0; i<length; i++)
            {
                cov_xy = cov_xy
                       + static_cast<double> (i)*static_cast<double> (pSrcY[i]);
            }
            // This is computed by expanding (x_i - bar(x))*(y_i - bar(y)),
            // using the definition of the mean, and simplifying
            cov_xy = (cov_xy/static_cast<double> (length)) - mean_x*mean_y;
            b1_ = cov_xy/var_x;
            b0_  = mean_y - b1_*mean_x;
            return 0; 
        }
        /// Sets the intercept 
        void setIntercept(const double b0)
        {
            b0_ = b0;
        }
        /// Sets the slope
        void setSlope(const double b1)
        {
            b1_ = b1;
        }
    private:
        /// Detrend parameters
        DetrendParameters parms_;
        /// The y-intercept
        double b0_ = 0;
        /// The slope
        double b1_ = 0;
        /// Flag indicating this is initialized
        bool linit_ = true;
};
//============================================================================//

DetrendParameters::DetrendParameters(const RTSeis::Precision precision) :
    precision_(precision),
    mode_(RTSeis::ProcessingMode::POST_PROCESSING),
    linit_(true)
{
    return;
}

DetrendParameters::DetrendParameters(const DetrendParameters &parameters)
{
    *this = parameters;
    return;
}

DetrendParameters&
    DetrendParameters::operator=(const DetrendParameters &parameters)
{
    if (&parameters == this){return *this;}
    precision_ = parameters.precision_;
    mode_ = parameters.mode_;
    linit_ = parameters.linit_;
    return *this;
}

DetrendParameters::~DetrendParameters(void)
{
    clear();
    return;
}

void DetrendParameters::clear(void)
{
    precision_ = defaultPrecision_;
    mode_ = RTSeis::ProcessingMode::POST_PROCESSING;
    linit_ = true; // Detrending is always ready to roll
    return;
}

RTSeis::Precision DetrendParameters::getPrecision(void) const
{
    return precision_;
}

RTSeis::ProcessingMode DetrendParameters::getProcessingMode(void) const
{
    return mode_;
}

bool DetrendParameters::isInitialized(void) const
{
    return linit_;
}
//============================================================================//
Detrend::Detrend(void) :
    pDetrend_(new DetrendImpl())
{
    clear();
    return;
}

Detrend::Detrend(const Detrend &detrend)
{
    *this = detrend;
    return;
}

Detrend::Detrend(const DetrendParameters &parameters) : 
    pDetrend_(new DetrendImpl())
{
    clear();
    int ierr = setParameters(parameters);
    if (ierr != 0){clear();}
    return;
}

Detrend& Detrend::operator=(const Detrend &detrend)
{
    if (&detrend == this){return *this;}
    if (pDetrend_){pDetrend_->clear();}
    pDetrend_ = std::unique_ptr<DetrendImpl>
                (new DetrendImpl(*detrend.pDetrend_));
    return *this;
}

Detrend::~Detrend(void)
{
    clear();
    return;
}

void Detrend::clear(void)
{
    pDetrend_->clear();
    return;
}

int Detrend::setParameters(const DetrendParameters &parameters)
{
    pDetrend_->clear();
    if (!parameters.isInitialized())
    {
        RTSEIS_ERRMSG("%s", "Detrend parameters are malformed");
        return -1;
    }
    pDetrend_->setParameters(parameters);
    return 0;
}

int Detrend::detrend(const int nx, const double x[], double y[])
{
    pDetrend_->setIntercept(0);
    pDetrend_->setSlope(0);
    if (nx <= 0){return 0;} // Nothing to do
    if (nx < 2 || x == nullptr || y == nullptr)
    {
        if (nx < 2){RTSEIS_ERRMSG("%s", "At least 2 points required");}
        if (x == nullptr){RTSEIS_ERRMSG("%s", "x is null");}
        if (y == nullptr){RTSEIS_ERRMSG("%s", "y is null");}
    }
    pDetrend_->detrend(nx, x, y);
    return 0;
}

int Detrend::detrend(const int nx, const float x[], float y[])
{
    pDetrend_->setIntercept(0);
    pDetrend_->setSlope(0);
    if (nx <= 0){return 0;} // Nothing to do
    if (nx < 2 || x == nullptr || y == nullptr)
    {
        if (nx < 2){RTSEIS_ERRMSG("%s", "At least 2 points required");}
        if (x == nullptr){RTSEIS_ERRMSG("%s", "x is null");}
        if (y == nullptr){RTSEIS_ERRMSG("%s", "y is null");}
    }
    pDetrend_->detrend(nx, x, y);
    return 0;
}
