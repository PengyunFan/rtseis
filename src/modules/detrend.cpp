#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ipps.h>
#define RTSEIS_LOGGING 1
#include "rtseis/log.h"
#include "rtseis/modules/detrend.h"

using namespace RTSeis::Modules;

/*!
 * @defgroup rtseis_modules_detrend Detrend
 * @brief Removes the trend from the data.
 * @ingroup rtseis_modules
 */

/*!
 * @brief Default constructor.
 * @ingroup rtseis_modules_detrend
 */
Detrend::Detrend(void)
{
    return;
}
/*!
 * @brief Default destructor.
 * @ingroup rtseis_modules_detrend
 */
Detrend::~Detrend(void)
{
    b0_ = 0;
    b1_ = 0;
    return;
}
/*!
 * @brief Sets the parameters for the detrend class.
 * @param[in] precision  RTSEIS_DOUBLE indicates that double precision
 *                       calculations will be used.
 * @param[in] precision  RTSEIS_FLOAT indicates that float precision
 *                       calculations will be used.
 * @result 0 indicates success.
 * @ingroup rtseis_modules_detrend
 */
int Detrend::setParameters(const enum rtseisPrecision_enum precision)
{
    precision_ = RTSEIS_DOUBLE;
    if (precision != RTSEIS_DOUBLE && precision != RTSEIS_FLOAT)
    {
        RTSEIS_ERRMSG("Invalid precision %d", (int) precision);
        return -1;
    }
    precision_ = precision;
    return 0;
}
/*!
 * @brief Removes the trend from the data by fitting a best-fitting line.
 * @param[in] nx   Number of points in x.
 * @param[in] x    Signal from which to remove trend.  This is an array of
 *                 dimension [nx].
 * @param[out] y   The detrended version of x.  This is an array of
 *                 dimension [nx].
 * @result 0 indicates success.
 * @ingroup rtseis_modules_detrend
 */
int Detrend::detrend(const int nx, const double x[], double y[])
{
    b0_ = 0;
    b1_ = 0;
    if (nx < 1 || x == nullptr || y == nullptr)
    {
        if (nx < 1){RTSEIS_ERRMSG("%s", "No points");}
        if (x == nullptr){RTSEIS_ERRMSG("%s", "x is null");}
        if (y == nullptr){RTSEIS_ERRMSG("%s", "y is null");}
    }
    if (precision_ == RTSEIS_DOUBLE)
    {
        computeLinearRegressionCoeffs_(nx, x);
        removeTrend_(nx, x, y);
    }
    else
    {
        float *x32 = ippsMalloc_32f(nx);
        float *y32 = ippsMalloc_32f(nx);
        ippsConvert_64f32f(x, x32, nx);
        int ierr = detrend(nx, x32, y32);
        if (ierr == 0){ippsConvert_32f64f(y32, y, nx);}
        ippsFree(x32);
        ippsFree(y32);
        return ierr;
    }
    return 0;
}
/*!
 * @copydoc Detrend::compute
 * @ingroup rtseis_modules_detrend
 */
int Detrend::detrend(const int nx, const float x[], float y[])
{
    b0_ = 0; 
    b1_ = 0;
    if (nx < 1 || x == nullptr || y == nullptr)
    {
        if (nx < 1){RTSEIS_ERRMSG("%s", "No points");}
        if (x == nullptr){RTSEIS_ERRMSG("%s", "x is null");}
        if (y == nullptr){RTSEIS_ERRMSG("%s", "y is null");}
    }
    if (precision_ == RTSEIS_FLOAT)
    {
        computeLinearRegressionCoeffs_(nx, x);
        removeTrend_(nx, x, y);
    }
    else
    {
        double *x64 = ippsMalloc_64f(nx);
        double *y64 = ippsMalloc_64f(nx);
        ippsConvert_32f64f(x, x64, nx);
        int ierr = detrend(nx, x64, y64);
        if (ierr == 0){ippsConvert_64f32f(y64, y, nx);}
        ippsFree(x64);
        ippsFree(y64);
        return ierr;
    }
    return 0;
}
/*!
 * @brief Computes the coefficients for a linear regression
 *          \f$ \hat{y}_i = b_0 + b_1 x_i \f$
 *        using IPP functions where
 *          \f$ b_1
 *           = \frac{\mathrm{Cov}(x,y)}{\mathrm{Var}(x,y)} \f$
 *        and 
 *          \f$ b_0 = \bar{y} - b_0 \bar{x} \f$.
 *        The code is modified from:
 *        https://software.intel.com/en-us/forums/intel-integrated-performance-primitives/topic/299457 
 *        where I have assumed the data is generated by linearly spaced samples.
 * @param[in] length  Length of array y.
 * @param[in] pSrcY   Points at evaluated at indices.
 * @ingroup rtseis_modules_detrend
 */
int Detrend::computeLinearRegressionCoeffs_(
    const int length, const double pSrcY[])
{
    double cov_xy;
    double mean_x;
    double mean_y;
    double var_x;
    // Mean of x - analytic formula for evenly spaced samples starting at indx 0
    // This is computed by simplifying Gauss's formula.
    mean_x = 0.5*static_cast<double> (length - 1);
    var_x = static_cast<double> ( ((length - 1)*length)*(2*(length - 1) + 1) )
           /static_cast<double> ( 6*length ) - mean_x*mean_x;
    ippsMean_64f(pSrcY, length, &mean_y);
    cov_xy = 0;
    #pragma omp simd reduction(+:cov_xy)
    for (int i=0; i<length; i++)
    {
        cov_xy = cov_xy + static_cast<double> (i)*pSrcY[i];
    }
    // This is computed by expanding (x_i - bar(x))*(y_i - bar(y)), using 
    // the definition of the mean, and simplifying
    cov_xy = (cov_xy/static_cast<double> (length)) - mean_x*mean_y;
    b1_ = cov_xy/var_x;
    b0_  = mean_y - b1_*mean_x;
    return 0;
}
/*!
 * @copydoc Detrend::computeLinearRegressionCoeffs_
 * @ingroup rtseis_modules_detrend
 */
int Detrend::computeLinearRegressionCoeffs_(
    const int length, const float pSrcY[])
{
    double cov_xy;
    double mean_x;
    double mean_y;
    double var_x;
    float mean_y32;
    // Mean of x - analytic formula for evenly spaced samples starting at indx 0
    // This is computed by simplifying Gauss's formula.
    mean_x = 0.5*static_cast<double> (length - 1); 
    var_x = static_cast<double> ( ((length - 1)*length)*(2*(length - 1) + 1) )
           /static_cast<double> ( 6*length ) - mean_x*mean_x;
    ippsMean_32f(pSrcY, length, &mean_y32, ippAlgHintAccurate);
    mean_y = static_cast<double> (mean_y32);
    cov_xy = 0;
    #pragma omp simd reduction(+:cov_xy)
    for (int i=0; i<length; i++)
    {
        cov_xy = cov_xy
              + static_cast<double> (i)*static_cast<double> (pSrcY[i]);
    }
    // This is computed by expanding (x_i - bar(x))*(y_i - bar(y)), using 
    // the definition of the mean, and simplifying
    cov_xy = (cov_xy/static_cast<double> (length)) - mean_x*mean_y;
    b1_ = cov_xy/var_x;
    b0_  = mean_y - b1_*mean_x;
    return 0;
}
/*!
 * @brief Removes the trend from the data.
 * @param[in] length    Length of the time series.
 * @param[in] x         Time series from which to remove trend.  This has
 *                      dimension [length].
 * @param[out] y        The time series with the trend removed.  This has
 *                      dimension [length].
 * @result 0 indicates success.
 * @ingroup rtseis_modules_detrend
 */
int Detrend::removeTrend_(const int length, const double x[], double y[])
{
    #pragma omp simd
    for (int i=0; i<length; i++)
    {
        y[i] = x[i] - (b0_ + b1_*static_cast<double> (i));
    }
    return 0;
}
/*!
 * @copydoc Detrend::removeTrend_
 * @ingroup rtseis_modules_detrend
 */
int Detrend::removeTrend_(const int length, const float x[], float y[])
{
    float b0 = static_cast<float> (b0_);
    float b1 = static_cast<float> (b1_);
    #pragma omp simd
    for (int i=0; i<length; i++)
    {
        y[i] = x[i] - (b0 + b1*static_cast<float> (i));
    }
    return 0;
}
